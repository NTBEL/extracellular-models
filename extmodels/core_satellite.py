"""Model of somatostatin brain extracellular release, diffusion, loss and detection.
"""

from neuron import h, rxd
from neuron.units import nM, uM, cm, s, M, nm, um
import numpy as np

# Avogadro's Number from scipy
from scipy.constants import N_A
from .basemodel import ModelBase


class Model(ModelBase):
    """A model of somatostatin release, diffusion, loss, and detection in the brain extracellular space.

    This model simulates the photorelease of the neuropeptide somatostatin from
    gold coated nanovesicles, its subsequent diffusion in the brain
    extracellular space, and approximates it detection using the CNiFERs-based
    core-satellite implant design described in:
        Xiong et al. 2021 bioRxiv https://doi.org/10.1101/2021.09.10.459853
    An initial cylindrical bolus of somatostatin is placed in
    the center of the extracellular domain to approximate the condition after
    photorelease from gold coated nanovesicles with release stimulated by a
    tornado scan of radius 30 micron with a multi-photon microscope. Somatostatin
    can then diffuse away from the release site and can be lost from the
    extracellular space through a first order decay reaction. CNiFERs
    detect SST through SST binding to a GPCR that triggers Ca2+ release and
    generates a signal from an intracellular Ca2+ FRET sensor. Here, we simplify
    the model by assuming the CNiFER signal is generated by receptor binding; this
    would be akin to having CNiFER-like cells that express a receptor-based
    fluorescent sensor (like dLight or kLight). A core CNiFER is
    placed at the ceter of the extracellular domain and is modeled as a spherical
    domain with a fixed concentration of receptor-based sensors. The satellite
    CNiFER is modeled similarly and is placed a fixed distance away from the
    core CNiFER.

    Model components (accessible as model attributes):

        Compartments:
            ecs -> rxd.Extracellular: The extracellular space domain and its
                parameters like volume fraction and tortuosity.
        Species:
            sst -> rxd.Species: Neuropeptide somatostatin (sst) that is
                photoreleased in the brain extracellular space.
            sensor -> rxd.Species: The receptor-based sensor for dynophin.
            sensor_complex -> rxd.Species: The complex between dynorpin and the
                    sensor.
        Parameters:
            Kd -> rxd.Parameter: The dissociation constant for the SST-sensor
                interaction.
            kon -> rxd.Parameter: The forward kinetic rate constant (on rate) for
                 second order binding of SST to the sensor protein.
            koff -> rxd.Parameter: The reverse kinetic rate constant (off rate) for
                the first order unbinding of SST from the sensor protein.
            loss_rate -> rxd.Parameter: Defines the kinetic rate for first order
                loss of sst from the extracellular space.
        Reactions:
            sensor_binding -> rxd.Rate: The reaction corresponding to reversible
                binding of SST to the sensor protein.
                Forward reaction: sst + sensor --kon--> sst:sensor
                Reverse reaction: sst:sensor --koff--> sst + sensor
            sst_loss -> rxd.Rate: The reaction corresponding to first order loss
                of sst from the extracellular space.
                Forward reaction: sst --loss_rate--> None

    """

    def __init__(
        self,
        volume_fraction: float = 0.2,
        tortuosity: float = 1.0,
        dx: float = 5,
        xlo: float = -200.0,
        xhi: float = 200.0,
        ylo: float = -200.0,
        yhi: float = 200.0,
        zlo: float = -200.0,
        zhi: float = 200.0,
    ):
        """Defines and constructs all the model components.

        Args:
            volume_fraction: The volume fraction of extracellular space
                (unitless). DEFAULT: 0.2
            tortuosity: The tortuosity for diffusion in the extracellular space
                (unitless). DEFAULT: 1.
            dx: The discrettization size for volume voxels in the extracellular
                space in microns. DEFAUT: 5
            xlo: The position of the lower edge of the extracellular simulation
                domain along the x-direction in microns. DEFAULT: -200.
            xhi: The position of the upper edge of the extracellular simulation
                domain along the x-direction in microns. DEFAULT: 200.
            ylo: The position of the lower edge of the extracellular simulation
                domain along the y-direction in microns. DEFAULT: -200.
            yhi: The position of the upper edge of the extracellular simulation
                domain along the y-direction in microns. DEFAULT: 200.
            zlo: The position of the lower edge of the extracellular simulation
                domain along the z-direction in microns. DEFAULT: -200.
            zhi: The position of the upper edge of the extracellular simulation
                domain along the z-direction in microns. DEFAULT: 200.
        """
        # Where? -- specify the regions
        # For extracellular reaction-diffusion we just have one
        # Extracellular region.
        self.ecs = rxd.Extracellular(
            xlo=xlo,
            ylo=ylo,
            zlo=zlo,
            xhi=xhi,
            yhi=yhi,
            zhi=zhi,
            dx=dx,
            volume_fraction=volume_fraction,
            tortuosity=tortuosity,
        )
        # Who? -- define all the species
        # Calcein
        # The effective diffusion coefficient for fluorescently labelled SST
        # in acute brain slices from integrative optical imaging (IOI) is
        # 8.9+-1.3 x10^-7 cm^2/s. Xiong et al. 2021 bioRxiv https://doi.org/10.1101/2021.09.10.459853
        d_sst = (
            8.9e-7 * cm ** 2 / s
        )  # effective diffusion coefficient (factoring in tortuosity)
        # Approximate SST photorelease from gold coated nanovesicles as in
        # Xiong et al. 2021 bioRxiv https://doi.org/10.1101/2021.09.10.459853
        # Use an initial bolus of SST with a uniform concentration corresponding
        # to the estimated 1.2x10^8 released molecs inside a disc that
        # approximates the two-photon tornado scan area used for nanovesicle
        # release.
        r_stim = 30 * um  # radius of the tornado scan area
        Qsst = 1.2e8  # Number of SST molecules released during photostimulation
        focal_disc_z = 12  # z-height of the 2-photon focal plane
        disc_vol = (
            np.pi * r_stim ** 2 * focal_disc_z
        )  # volume of the tornado scan area.
        # SST concentration accounting for the disc volume and volume faction.
        sst_0 = ((Qsst / N_A) / disc_vol) / volume_fraction * 1e15 * M
        self.sst = rxd.Species(
            self.ecs,
            name="somatostatin",
            d=d_sst,
            charge=0,
            initial=lambda nd: sst_0
            if (
                (nd.x3d ** 2 + nd.y3d ** 2 < r_stim ** 2)
                and (np.abs(nd.z3d) < focal_disc_z / 2)
            )
            else 0,
            ecs_boundary_conditions=0.0,
        )
        # The sensor
        # We'll assume that the sensor distribution can be approximated as
        # a uniform concentration throught the core and satellite implants.
        sensor_0 = 1 * nM  # sensor concentration inside the implants.
        self._sensor_0 = sensor_0
        radius_core = 15  # radius of the core sensor implant in microns.
        self._radius_core = radius_core
        radius_satellite = 15  # radius of the satellite sensor implant in microns.
        self._radius_satellite = radius_satellite
        distance_core_satellite = (
            100  # distance between the centers of the core and satellite implants.
        )
        self._distance_core_satellite = distance_core_satellite
        self.sensor = rxd.Species(
            self.ecs,
            name="sensor",
            d=0,
            atolscale=1e-6,
            initial=lambda nd: sensor_0
            if (nd.x3d ** 2 + nd.y3d ** 2 + nd.z3d ** 2 < radius_core ** 2)
            or (
                (nd.x3d - distance_core_satellite) ** 2 + nd.y3d ** 2 + nd.z3d ** 2
                < radius_satellite ** 2
            )
            else 0,
        )
        # SST bound to the sensor
        self.sensor_complex = rxd.Species(
            self.ecs, name="sensor-sst", d=0, initial=0, atolscale=1e-6
        )
        # What? -- specify all the reactions
        # sst binding to the sensor.
        # The detection threshold for CNiFERs 0.5-1.5 nM Xiong et al. 2021 bioRxiv https://doi.org/10.1101/2021.09.10.459853
        # We can use that to set the sst-sensor dissociation constant Kd
        Kd_sst = 1 * nM  # dissociation constant for sst and sensor
        # sst-sensor reaction radius - assume 2.5 nm, which is close
        # to half of the vertical height of KOR (~5 nm) roughly estimated from
        # the 6b73 PDB structure: https://www.rcsb.org/structure/6b73
        rad_on = 2.5e-7  # cm
        # Assume the binding rate is diffusion controlled:
        # 4piD*r => mL/s/molec. * 1e-3 => L/s/molec. * N_A (molec./mol) => 1/s/M
        kon = (
            (4 * np.pi * (d_sst * s / cm ** 2) * rad_on * 1e-3) * N_A / (M * s)
        )  # on rate

        self.Kd = rxd.Parameter(self.ecs, name="Kd", value=Kd_sst)
        self.kon = rxd.Parameter(self.ecs, name="kon", value=kon)
        self.koff = rxd.Parameter(
            self.ecs, name="koff", value=self.Kd.value * self.kon.value
        )  # off rate
        self.sensor_binding = rxd.Reaction(
            self.sst + self.sensor, self.sensor_complex, self.kon, self.koff
        )
        # 1st-order loss of SST
        # Loss rate of SST estimated in range 0.023-0.048 per second.
        # Xiong et al. 2021 bioRxiv https://doi.org/10.1101/2021.09.10.459853
        kf = 3.6e-2 / s  # the reaction rate
        self.loss_rate = rxd.Parameter(self.ecs, value=kf)
        self.sst_loss = rxd.Rate(self.sst, -self.loss_rate * self.sst)

        # Initialize private variables -- required for all models
        self._times = None  # We'll store the time points in our simulation trajectory.
        self._observables = None  # We'll assign our observables to this variable.
        return

    def simulate(
        self,
        time_step: float,
        n_steps: int,
        output_frequency: int = 1,
        nthread: int = 1,
    ):
        """Run the simulation and set the desired trajectory ouptuts.

        Args:
            time_step: The time interval between each step of the simulation
                trajectory in milliseconds. Times not in milliseconds can
                be converted using unit conversions from the neuron.units
                module.
            n_steps: The total number of simulation steps to run.
            output_frequency: Set the frequency for computing and storing
                any observables during the simulation. DEFAULT: 1
            nthread: The number threads to use for multithreaded parallelization
                when running the simulation. DEFAULT: 1

        """
        # Set the number of threads for the rxd module to use when simulating.
        rxd.nthread(nthread)
        # Set the time step and initialize the simulator.
        h.dt = time_step
        h.finitialize()
        # define any observables that you want to store
        times = list()
        sst_zproject_mean = list()
        sensor_complex_zproject_mean = list()
        # Run each step.
        for f in range(n_steps + 1):
            if (f == 0) or ((f % output_frequency) == 0):
                # simulation time
                times.append(f * time_step)
                # Get the mean value z-projection of the Calcein concentration.
                sst_zproject_mean.append(self.sst[self.ecs].states3d.mean(2))
                # Get the mean value z-projection of the sst-sensor complex concentration.
                sensor_complex_zproject_mean.append(
                    self.sensor_complex[self.ecs].states3d.mean(2)
                )
            h.fadvance()
        self._times = (
            np.array(times) * 1e-3
        )  # 1e-3 converts from milliseconds to seconds
        # 2d grid in x and y for masking to get core and satellite ROI averages
        n_pixels = self.sst[self.ecs].states3d.mean(2).shape
        xedges = np.linspace(
            self.ecs._xlo, self.ecs._xhi, n_pixels[0] + 1, endpoint=True
        )
        xpos = xedges[0:-1] + (xedges[1:] - xedges[:-1]) / 2
        yedges = np.linspace(
            self.ecs._ylo, self.ecs._yhi, n_pixels[1] + 1, endpoint=True
        )
        ypos = yedges[0:-1] + (yedges[1:] - yedges[:-1]) / 2
        # Generate a meshgrid for the x and y positions of pixels in micron
        yv, xv = np.meshgrid(ypos, xpos, indexing="ij")
        core_mask = (yv ** 2 + xv ** 2) < self._radius_core ** 2
        satellite_mask = (
            (yv - self._distance_core_satellite) ** 2 + xv ** 2
        ) < self._radius_satellite ** 2
        core_mean = list()
        satellite_mean = list()
        for zproj in sensor_complex_zproject_mean:
            core_mean.append(zproj[core_mask].mean())
            satellite_mean.append(zproj[satellite_mask].mean())
        self._observables = {
            "zproject_mean_sst": sst_zproject_mean,
            "zproject_mean_sensor_complex": sensor_complex_zproject_mean,
            "core_roi_mean": np.array(core_mean),
            "satellite_roi_mean": np.array(satellite_mean),
        }
        return

    @property
    def radius_satellite(self):
        """The radius of the satellite sensor implant."""
        return self._radius_satellite

    @radius_satellite.setter
    def radius_satellite(self, new_radius):
        self._radius_satellite = new_radius
        self.sensor.initial = (
            lambda nd: self._sensor_0
            if (nd.x3d ** 2 + nd.y3d ** 2 + nd.z3d ** 2 < self._radius_core ** 2)
            or (
                (nd.x3d - self._distance_core_satellite) ** 2
                + nd.y3d ** 2
                + nd.z3d ** 2
                < self._radius_satellite ** 2
            )
            else 0
        )

    @property
    def distance_core_satellite(self):
        """The radius of the satellite sensor implant."""
        return self._distance_core_satellite

    @distance_core_satellite.setter
    def distance_core_satellite(self, new_distance):
        self._distance_core_satellite = new_distance
        self.sensor.initial = (
            lambda nd: self._sensor_0
            if (nd.x3d ** 2 + nd.y3d ** 2 + nd.z3d ** 2 < self._radius_core ** 2)
            or (
                (nd.x3d - self._distance_core_satellite) ** 2
                + nd.y3d ** 2
                + nd.z3d ** 2
                < self._radius_satellite ** 2
            )
            else 0
        )


model = Model()
